# На входе вы получаете расписание самолетов в виде массива, каждый элемент которого это цена прямого воздушного
# соединения 2х городов (массив из 3х элементов - 2 названия города, в виде строки, и цена перелета).
#
# Самолеты летают в обе стороны и цена в обе стороны одинаковая. Есть вероятность, что соединения между городами
# может и не быть.
#
# Найдите цену самого дешевого перелета для городов, которые переданы 2ым и 3им аргументами.
#
# Input: 3 аргумента. Расписание перелетов в виде массива массивов. Город вылета и город назначения.
#
# Output: Int. Лучшая цена.
#
# Example:
#
# cheapest_flight([['A', 'C', 100],
#   ['A', 'B', 20],
#   ['B', 'C', 50]],
#  'A',
#  'C') == 70
# cheapest_flight([['A', 'C', 100],
#   ['A', 'B', 20],
#   ['B', 'C', 50]],
#  'C',
#  'A') == 70

# Как это используется: Может быть использовано в повседневной жизни для нахождения оптимальной комбинации.
#
# Precondition: Цена всегда int. В расписании рейсов есть хотя бы один элемент. Оба искомых города есть в расписании.
from typing import List


def cheapest_flight(costs: List, a: str, b: str) -> int:
    # your code here
    return None


if __name__ == '__main__':
    print("Example:")
    print(cheapest_flight([['A', 'C', 100],
  ['A', 'B', 20],
  ['B', 'C', 50]],
 'A',
 'C'))

    # These "asserts" are used for self-checking and not for an auto-testing
    assert cheapest_flight([['A', 'C', 100],
  ['A', 'B', 20],
  ['B', 'C', 50]],
 'A',
 'C') == 70
    assert cheapest_flight([['A', 'C', 100],
  ['A', 'B', 20],
  ['B', 'C', 50]],
 'C',
 'A') == 70
    assert cheapest_flight([['A', 'C', 40],
  ['A', 'B', 20],
  ['A', 'D', 20],
  ['B', 'C', 50],
  ['D', 'C', 70]],
 'D',
 'C') == 60
    assert cheapest_flight([['A', 'C', 100],
  ['A', 'B', 20],
  ['D', 'F', 900]],
 'A',
 'F') == 0
    assert cheapest_flight([['A', 'B', 10],
  ['A', 'C', 15],
  ['B', 'D', 15],
  ['C', 'D', 10]],
 'A',
 'D') == 25
    print("Coding complete? Click 'Check' to earn cool rewards!")
